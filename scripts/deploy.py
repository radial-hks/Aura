#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
AuraÁîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤ËÑöÊú¨
Êèê‰æõDockerÂÆπÂô®ÂåñÈÉ®ÁΩ≤„ÄÅÁ≥ªÁªüÊúçÂä°ÂÆâË£Ö„ÄÅÈÖçÁΩÆÁÆ°ÁêÜÁ≠âÂäüËÉΩ
"""

import os
import sys
import argparse
import subprocess
import shutil
import json
import yaml
from pathlib import Path
from typing import Dict, List, Optional
import tempfile
import tarfile

# Ê∑ªÂä†È°πÁõÆÊ†πÁõÆÂΩïÂà∞PythonË∑ØÂæÑ
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

class AuraDeployer:
    """AuraÈÉ®ÁΩ≤ÁÆ°ÁêÜÂô®"""
    
    def __init__(self):
        self.project_root = project_root
        self.build_dir = project_root / "build"
        self.dist_dir = project_root / "dist"
        
    def run_command(self, command: List[str], cwd: Optional[Path] = None, 
                   check: bool = True) -> subprocess.CompletedProcess:
        """ËøêË°åÂëΩ‰ª§"""
        print(f"üîß ÊâßË°å: {' '.join(command)}")
        
        result = subprocess.run(
            command,
            cwd=cwd or self.project_root,
            capture_output=True,
            text=True,
            check=check
        )
        
        if result.stdout:
            print(result.stdout)
        if result.stderr:
            print(result.stderr)
        
        return result
    
    def create_dockerfile(self) -> Path:
        """ÂàõÂª∫Dockerfile"""
        dockerfile_content = """
# AuraÊô∫ËÉΩÊµèËßàÂô®Ëá™Âä®ÂåñÁ≥ªÁªü - Áîü‰∫ßÁéØÂ¢ÉÈïúÂÉè
FROM python:3.11-slim

# ËÆæÁΩÆÂ∑•‰ΩúÁõÆÂΩï
WORKDIR /app

# ÂÆâË£ÖÁ≥ªÁªü‰æùËµñ
RUN apt-get update && apt-get install -y \
    wget \
    gnupg \
    ca-certificates \
    fonts-liberation \
    libasound2 \
    libatk-bridge2.0-0 \
    libatk1.0-0 \
    libatspi2.0-0 \
    libcups2 \
    libdbus-1-3 \
    libdrm2 \
    libgtk-3-0 \
    libnspr4 \
    libnss3 \
    libwayland-client0 \
    libxcomposite1 \
    libxdamage1 \
    libxfixes3 \
    libxkbcommon0 \
    libxrandr2 \
    xdg-utils \
    libu2f-udev \
    libvulkan1 \
    && rm -rf /var/lib/apt/lists/*

# ÂàõÂª∫ÈùûrootÁî®Êà∑
RUN useradd -m -u 1000 aura && \
    mkdir -p /app/logs /app/data /app/cache && \
    chown -R aura:aura /app

# Â§çÂà∂requirementsÊñá‰ª∂
COPY requirements.txt .

# ÂÆâË£ÖPython‰æùËµñ
RUN pip install --no-cache-dir -r requirements.txt

# ÂÆâË£ÖPlaywrightÊµèËßàÂô®
RUN playwright install chromium

# Â§çÂà∂Â∫îÁî®‰ª£Á†Å
COPY --chown=aura:aura . .

# ÂàáÊç¢Âà∞ÈùûrootÁî®Êà∑
USER aura

# Êö¥Èú≤Á´ØÂè£
EXPOSE 8000

# ÂÅ•Â∫∑Ê£ÄÊü•
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# ÂêØÂä®ÂëΩ‰ª§
CMD ["python", "scripts/start.py", "api", "--env", "production", "--host", "0.0.0.0", "--port", "8000"]
"""
        
        dockerfile_path = self.project_root / "Dockerfile"
        with open(dockerfile_path, "w", encoding="utf-8") as f:
            f.write(dockerfile_content.strip())
        
        print(f"‚úÖ DockerfileÂ∑≤ÂàõÂª∫: {dockerfile_path}")
        return dockerfile_path
    
    def create_docker_compose(self) -> Path:
        """ÂàõÂª∫docker-compose.yml"""
        compose_content = """
version: '3.8'

services:
  aura-api:
    build: .
    container_name: aura-api
    ports:
      - "8000:8000"
    environment:
      - AURA_ENV=production
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://aura:aura_password@postgres:5432/aura
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
      - ./cache:/app/cache
    depends_on:
      - redis
      - postgres
    restart: unless-stopped
    networks:
      - aura-network
  
  redis:
    image: redis:7-alpine
    container_name: aura-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - aura-network
  
  postgres:
    image: postgres:15-alpine
    container_name: aura-postgres
    environment:
      - POSTGRES_DB=aura
      - POSTGRES_USER=aura
      - POSTGRES_PASSWORD=aura_password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    networks:
      - aura-network
  
  nginx:
    image: nginx:alpine
    container_name: aura-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - aura-api
    restart: unless-stopped
    networks:
      - aura-network

volumes:
  redis_data:
  postgres_data:

networks:
  aura-network:
    driver: bridge
"""
        
        compose_path = self.project_root / "docker-compose.yml"
        with open(compose_path, "w", encoding="utf-8") as f:
            f.write(compose_content.strip())
        
        print(f"‚úÖ docker-compose.ymlÂ∑≤ÂàõÂª∫: {compose_path}")
        return compose_path
    
    def create_nginx_config(self) -> Path:
        """ÂàõÂª∫NginxÈÖçÁΩÆ"""
        nginx_content = """
events {
    worker_connections 1024;
}

http {
    upstream aura_api {
        server aura-api:8000;
    }
    
    # ÈôêÊµÅÈÖçÁΩÆ
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    
    # Êó•ÂøóÊ†ºÂºè
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    server {
        listen 80;
        server_name _;
        
        # ÈáçÂÆöÂêëÂà∞HTTPS
        return 301 https://$server_name$request_uri;
    }
    
    server {
        listen 443 ssl http2;
        server_name _;
        
        # SSLÈÖçÁΩÆ
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        
        # ÂÆâÂÖ®Â§¥
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains";
        
        # ËÆøÈóÆÊó•Âøó
        access_log /var/log/nginx/aura_access.log main;
        error_log /var/log/nginx/aura_error.log;
        
        # API‰ª£ÁêÜ
        location /api/ {
            limit_req zone=api burst=20 nodelay;
            
            proxy_pass http://aura_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocketÊîØÊåÅ
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            
            # Ë∂ÖÊó∂ËÆæÁΩÆ
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }
        
        # ÈùôÊÄÅÊñá‰ª∂
        location /static/ {
            alias /app/static/;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
        
        # ÂÅ•Â∫∑Ê£ÄÊü•
        location /health {
            proxy_pass http://aura_api/health;
        }
        
        # ÈªòËÆ§Ë∑ØÁî±
        location / {
            proxy_pass http://aura_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
"""
        
        nginx_path = self.project_root / "nginx.conf"
        with open(nginx_path, "w", encoding="utf-8") as f:
            f.write(nginx_content.strip())
        
        print(f"‚úÖ nginx.confÂ∑≤ÂàõÂª∫: {nginx_path}")
        return nginx_path
    
    def create_systemd_service(self) -> Path:
        """ÂàõÂª∫systemdÊúçÂä°Êñá‰ª∂"""
        service_content = f"""
[Unit]
Description=AuraÊô∫ËÉΩÊµèËßàÂô®Ëá™Âä®ÂåñÁ≥ªÁªü
After=network.target
Wants=network.target

[Service]
Type=simple
User=aura
Group=aura
WorkingDirectory={self.project_root}
Environment=AURA_ENV=production
Environment=PYTHONPATH={self.project_root}
ExecStart={sys.executable} scripts/start.py full --env production
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10

# ÂÆâÂÖ®ËÆæÁΩÆ
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths={self.project_root}/logs {self.project_root}/data {self.project_root}/cache

# ËµÑÊ∫êÈôêÂà∂
LimitNOFILE=65536
LimitNPROC=4096

[Install]
WantedBy=multi-user.target
"""
        
        service_path = self.project_root / "aura.service"
        with open(service_path, "w", encoding="utf-8") as f:
            f.write(service_content.strip())
        
        print(f"‚úÖ systemdÊúçÂä°Êñá‰ª∂Â∑≤ÂàõÂª∫: {service_path}")
        return service_path
    
    def create_deployment_config(self, environment: str) -> Path:
        """ÂàõÂª∫ÈÉ®ÁΩ≤ÈÖçÁΩÆ"""
        config = {
            "environment": environment,
            "version": "1.0.0",
            "deployment": {
                "method": "docker",  # docker, systemd, manual
                "replicas": 1,
                "resources": {
                    "cpu": "1000m",
                    "memory": "2Gi"
                }
            },
            "database": {
                "host": "localhost",
                "port": 5432,
                "name": "aura",
                "user": "aura"
            },
            "redis": {
                "host": "localhost",
                "port": 6379
            },
            "monitoring": {
                "enabled": True,
                "prometheus_port": 9090,
                "grafana_port": 3000
            },
            "backup": {
                "enabled": True,
                "schedule": "0 2 * * *",  # ÊØèÂ§©ÂáåÊô®2ÁÇπ
                "retention_days": 30
            }
        }
        
        config_path = self.project_root / f"deploy-{environment}.yaml"
        with open(config_path, "w", encoding="utf-8") as f:
            yaml.dump(config, f, default_flow_style=False, allow_unicode=True)
        
        print(f"‚úÖ ÈÉ®ÁΩ≤ÈÖçÁΩÆÂ∑≤ÂàõÂª∫: {config_path}")
        return config_path
    
    def build_docker_image(self, tag: str = "aura:latest"):
        """ÊûÑÂª∫DockerÈïúÂÉè"""
        print(f"üê≥ ÊûÑÂª∫DockerÈïúÂÉè: {tag}")
        
        # ÂàõÂª∫Dockerfile
        self.create_dockerfile()
        
        # ÊûÑÂª∫ÈïúÂÉè
        self.run_command(["docker", "build", "-t", tag, "."])
        
        print(f"‚úÖ DockerÈïúÂÉèÊûÑÂª∫ÂÆåÊàê: {tag}")
    
    def deploy_docker(self, environment: str = "production"):
        """DockerÈÉ®ÁΩ≤"""
        print(f"üöÄ ÂºÄÂßãDockerÈÉ®ÁΩ≤ ({environment})...")
        
        # ÂàõÂª∫ÈÉ®ÁΩ≤Êñá‰ª∂
        self.create_docker_compose()
        self.create_nginx_config()
        
        # ÂàõÂª∫ÂøÖË¶ÅÁõÆÂΩï
        for dir_name in ["logs", "data", "cache", "ssl"]:
            (self.project_root / dir_name).mkdir(exist_ok=True)
        
        # ÊûÑÂª∫ÈïúÂÉè
        self.build_docker_image()
        
        # ÂêØÂä®ÊúçÂä°
        self.run_command(["docker-compose", "up", "-d"])
        
        print("‚úÖ DockerÈÉ®ÁΩ≤ÂÆåÊàê")
        print("üìç APIÂú∞ÂùÄ: http://localhost:8000")
        print("üìö APIÊñáÊ°£: http://localhost:8000/docs")
        print("üîß ÁÆ°ÁêÜÂëΩ‰ª§:")
        print("  docker-compose logs -f    # Êü•ÁúãÊó•Âøó")
        print("  docker-compose stop       # ÂÅúÊ≠¢ÊúçÂä°")
        print("  docker-compose restart    # ÈáçÂêØÊúçÂä°")
    
    def deploy_systemd(self, environment: str = "production"):
        """systemdÈÉ®ÁΩ≤"""
        print(f"üîß ÂºÄÂßãsystemdÈÉ®ÁΩ≤ ({environment})...")
        
        # ÂàõÂª∫ÊúçÂä°Êñá‰ª∂
        service_file = self.create_systemd_service()
        
        # ÂàõÂª∫Áî®Êà∑
        try:
            self.run_command(["sudo", "useradd", "-r", "-s", "/bin/false", "aura"], check=False)
        except subprocess.CalledProcessError:
            print("Áî®Êà∑auraÂ∑≤Â≠òÂú®")
        
        # ËÆæÁΩÆÊùÉÈôê
        self.run_command(["sudo", "chown", "-R", "aura:aura", str(self.project_root)])
        
        # ÂÆâË£ÖÊúçÂä°Êñá‰ª∂
        self.run_command(["sudo", "cp", str(service_file), "/etc/systemd/system/"])
        
        # ÈáçËΩΩsystemd
        self.run_command(["sudo", "systemctl", "daemon-reload"])
        
        # ÂêØÁî®Âπ∂ÂêØÂä®ÊúçÂä°
        self.run_command(["sudo", "systemctl", "enable", "aura"])
        self.run_command(["sudo", "systemctl", "start", "aura"])
        
        print("‚úÖ systemdÈÉ®ÁΩ≤ÂÆåÊàê")
        print("üîß ÁÆ°ÁêÜÂëΩ‰ª§:")
        print("  sudo systemctl status aura    # Êü•ÁúãÁä∂ÊÄÅ")
        print("  sudo systemctl stop aura      # ÂÅúÊ≠¢ÊúçÂä°")
        print("  sudo systemctl restart aura   # ÈáçÂêØÊúçÂä°")
        print("  sudo journalctl -u aura -f    # Êü•ÁúãÊó•Âøó")
    
    def create_backup_script(self) -> Path:
        """ÂàõÂª∫Â§á‰ªΩËÑöÊú¨"""
        backup_content = f"""
#!/bin/bash
# AuraÁ≥ªÁªüÂ§á‰ªΩËÑöÊú¨

set -e

BACKUP_DIR="/var/backups/aura"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/aura_backup_$DATE.tar.gz"
RETENTION_DAYS=30

# ÂàõÂª∫Â§á‰ªΩÁõÆÂΩï
mkdir -p $BACKUP_DIR

echo "ÂºÄÂßãÂ§á‰ªΩAuraÁ≥ªÁªü..."

# Â§á‰ªΩÂ∫îÁî®Êï∞ÊçÆ
tar -czf $BACKUP_FILE \
    -C {self.project_root} \
    --exclude='logs/*' \
    --exclude='cache/*' \
    --exclude='__pycache__' \
    --exclude='.git' \
    .

# Â§á‰ªΩÊï∞ÊçÆÂ∫ì
if command -v pg_dump &> /dev/null; then
    pg_dump -h localhost -U aura aura > $BACKUP_DIR/database_$DATE.sql
    gzip $BACKUP_DIR/database_$DATE.sql
fi

# Ê∏ÖÁêÜÊóßÂ§á‰ªΩ
find $BACKUP_DIR -name "aura_backup_*.tar.gz" -mtime +$RETENTION_DAYS -delete
find $BACKUP_DIR -name "database_*.sql.gz" -mtime +$RETENTION_DAYS -delete

echo "Â§á‰ªΩÂÆåÊàê: $BACKUP_FILE"
"""
        
        backup_path = self.project_root / "scripts" / "backup.sh"
        with open(backup_path, "w", encoding="utf-8") as f:
            f.write(backup_content.strip())
        
        # ËÆæÁΩÆÊâßË°åÊùÉÈôê
        backup_path.chmod(0o755)
        
        print(f"‚úÖ Â§á‰ªΩËÑöÊú¨Â∑≤ÂàõÂª∫: {backup_path}")
        return backup_path
    
    def create_monitoring_config(self) -> Path:
        """ÂàõÂª∫ÁõëÊéßÈÖçÁΩÆ"""
        prometheus_config = """
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'aura-api'
    static_configs:
      - targets: ['localhost:8000']
    metrics_path: '/metrics'
    scrape_interval: 10s

  - job_name: 'node-exporter'
    static_configs:
      - targets: ['localhost:9100']

  - job_name: 'redis'
    static_configs:
      - targets: ['localhost:9121']

  - job_name: 'postgres'
    static_configs:
      - targets: ['localhost:9187']
"""
        
        monitoring_dir = self.project_root / "monitoring"
        monitoring_dir.mkdir(exist_ok=True)
        
        prometheus_path = monitoring_dir / "prometheus.yml"
        with open(prometheus_path, "w", encoding="utf-8") as f:
            f.write(prometheus_config.strip())
        
        print(f"‚úÖ ÁõëÊéßÈÖçÁΩÆÂ∑≤ÂàõÂª∫: {prometheus_path}")
        return prometheus_path
    
    def package_release(self, version: str) -> Path:
        """ÊâìÂåÖÂèëÂ∏ÉÁâàÊú¨"""
        print(f"üì¶ ÊâìÂåÖÂèëÂ∏ÉÁâàÊú¨: {version}")
        
        # ÂàõÂª∫ÊûÑÂª∫ÁõÆÂΩï
        self.build_dir.mkdir(exist_ok=True)
        self.dist_dir.mkdir(exist_ok=True)
        
        # Ê∏ÖÁêÜÊóßÊñá‰ª∂
        for file in self.build_dir.glob("*"):
            if file.is_file():
                file.unlink()
            else:
                shutil.rmtree(file)
        
        # Â§çÂà∂Ê∫ê‰ª£Á†Å
        exclude_patterns = {
            '__pycache__', '.git', '.pytest_cache', 'node_modules',
            'logs', 'cache', 'build', 'dist', '.env*'
        }
        
        for item in self.project_root.iterdir():
            if item.name not in exclude_patterns:
                if item.is_file():
                    shutil.copy2(item, self.build_dir)
                else:
                    shutil.copytree(item, self.build_dir / item.name)
        
        # ÂàõÂª∫ÁâàÊú¨‰ø°ÊÅØ
        version_info = {
            "version": version,
            "build_date": subprocess.check_output(
                ["date", "-Iseconds"], text=True
            ).strip(),
            "git_commit": subprocess.check_output(
                ["git", "rev-parse", "HEAD"], text=True
            ).strip() if (self.project_root / ".git").exists() else "unknown"
        }
        
        with open(self.build_dir / "version.json", "w") as f:
            json.dump(version_info, f, indent=2)
        
        # ÂàõÂª∫ÂéãÁº©ÂåÖ
        archive_name = f"aura-{version}.tar.gz"
        archive_path = self.dist_dir / archive_name
        
        with tarfile.open(archive_path, "w:gz") as tar:
            tar.add(self.build_dir, arcname=f"aura-{version}")
        
        print(f"‚úÖ ÂèëÂ∏ÉÂåÖÂ∑≤ÂàõÂª∫: {archive_path}")
        return archive_path
    
    def health_check(self, url: str = "http://localhost:8000"):
        """ÂÅ•Â∫∑Ê£ÄÊü•"""
        print(f"üè• ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•: {url}")
        
        try:
            import requests
            
            # Ê£ÄÊü•APIÂÅ•Â∫∑Áä∂ÊÄÅ
            response = requests.get(f"{url}/health", timeout=10)
            response.raise_for_status()
            
            health_data = response.json()
            print(f"‚úÖ APIÂÅ•Â∫∑Áä∂ÊÄÅ: {health_data.get('status', 'unknown')}")
            
            # Ê£ÄÊü•ÂêÑÁªÑ‰ª∂Áä∂ÊÄÅ
            for component, status in health_data.get('components', {}).items():
                status_icon = "‚úÖ" if status == "healthy" else "‚ùå"
                print(f"  {status_icon} {component}: {status}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•: {e}")
            return False

def main():
    """‰∏ªÂáΩÊï∞"""
    parser = argparse.ArgumentParser(
        description="AuraÁîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤ÁÆ°ÁêÜÂô®",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Á§∫‰æãÁî®Ê≥ï:
  python scripts/deploy.py docker                    # DockerÈÉ®ÁΩ≤
  python scripts/deploy.py systemd                   # systemdÈÉ®ÁΩ≤
  python scripts/deploy.py build --tag aura:v1.0     # ÊûÑÂª∫DockerÈïúÂÉè
  python scripts/deploy.py package --version 1.0.0   # ÊâìÂåÖÂèëÂ∏ÉÁâàÊú¨
  python scripts/deploy.py health                     # ÂÅ•Â∫∑Ê£ÄÊü•
        """
    )
    
    parser.add_argument(
        'command',
        choices=['docker', 'systemd', 'build', 'package', 'health', 'backup'],
        help='ÈÉ®ÁΩ≤ÂëΩ‰ª§'
    )
    
    parser.add_argument(
        '--environment', '-e',
        choices=['production', 'staging'],
        default='production',
        help='ÈÉ®ÁΩ≤ÁéØÂ¢É (ÈªòËÆ§: production)'
    )
    
    parser.add_argument(
        '--tag', '-t',
        default='aura:latest',
        help='DockerÈïúÂÉèÊ†áÁ≠æ (ÈªòËÆ§: aura:latest)'
    )
    
    parser.add_argument(
        '--version', '-v',
        help='ÂèëÂ∏ÉÁâàÊú¨Âè∑'
    )
    
    parser.add_argument(
        '--url',
        default='http://localhost:8000',
        help='ÂÅ•Â∫∑Ê£ÄÊü•URL (ÈªòËÆ§: http://localhost:8000)'
    )
    
    args = parser.parse_args()
    
    deployer = AuraDeployer()
    
    try:
        if args.command == 'docker':
            deployer.deploy_docker(args.environment)
        
        elif args.command == 'systemd':
            deployer.deploy_systemd(args.environment)
        
        elif args.command == 'build':
            deployer.build_docker_image(args.tag)
        
        elif args.command == 'package':
            if not args.version:
                print("‚ùå ÊâìÂåÖÂëΩ‰ª§ÈúÄË¶ÅÊåáÂÆöÁâàÊú¨Âè∑")
                sys.exit(1)
            deployer.package_release(args.version)
        
        elif args.command == 'health':
            if not deployer.health_check(args.url):
                sys.exit(1)
        
        elif args.command == 'backup':
            deployer.create_backup_script()
        
    except Exception as e:
        print(f"‚ùå ÈÉ®ÁΩ≤ÂëΩ‰ª§Â§±Ë¥•: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()